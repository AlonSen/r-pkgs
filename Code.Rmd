# (PART) Package components {-}

```{r, include = FALSE}
source("common.R")
```

# R code {#r}

The first principle of using a package is that all R code goes in `R/`.
In this chapter, you'll learn about the `R/` directory, our recommendations for organising your functions into files, and some general tips on good style.
You'll also learn some important differences between defining a function in a script and defining it in a package.

## R code workflow {#r-workflow}

As your use of R becomes more sophisticated, it's common to start to write your own R functions.
If a function is only used in one place, you probably define it right there.
But if you've bothered to write a function, it's likely you want to reuse it in multiple places: within one script, across multiple scripts, or even across multiple projects.
This is *exactly* what an R package is for!

Without package technology, you probably collect these function definitions in one or more dedicated `.R` files and then `source()` them as needed.
Typically these functions co-evolve with the code where you use them, i.e. your analysis code, your Shiny apps, or your R Markdown reports.
If you use these functions across multiple projects, you also face the uncomfortable dilemma of where to define them and whether to have multiple, slightly different copies of this code lying around.

The first practical advantage to making your own functions available as a **package** is that it's easy to re-load them, as you refine their functionality or interface.
Instead of re-running multiple `source()` commands, you can use `devtools::load_all()` to make the updated versions of your package's functions available.

:::rstudio-tip
RStudio exposes `load_all()` in the *Build* menu, in the *Build* pane via *More > Load All*, and in keyboard shortcuts Ctrl + Shift + L (Windows & Linux) or Cmd + Shift + L (macOS). When run inside RStudio `load_all()` also saves all open files, saving you a keystroke.
:::

This keyboard shortcut leads to a fluid development workflow:

1. Edit an R file.

1. Execute `load_all()`, probably via Ctrl/Cmd + Shift + L.

1. Explore the code in the console.

1. Rinse and repeat.

Congratulations!
You've learned your first package development workflow.
Even if you learn nothing else from this book, you'll have gained a useful workflow for editing and reloading R code.

## Organising your functions into files {#r-organising}

*We originally decided to remove this in deference to material in <https://style.tidyverse.org>. The removed text is in [tidyverse/style/#121](https://github.com/tidyverse/style/issues/121). In hindsight, I think removal is too extreme and I've re-introduced this section. First, the original material really isn't in style.tidyverse.org (yet?). Second, people really want guidance on this and it feels misguided to omit from this book out of some adherence to the DRY principle.*

The only hard rule is that your package should store its function definitions in R scripts, i.e. files with extension `.R`, that live in the `R/` directory[^no-subdirs].
However, a few more conventions can make the source code of your package easier to navigate and relieve you of re-answering "How should I name this?" each time you create a new file[^file-style].

[^no-subdirs]: Unfortunately you can't use subdirectories inside `R/`.
The next best thing is to use a common prefix, e.g., `abc-*.R`.

[^file-style]: More advice about naming and organising R files is in The Tidyverse Style Guide.
General advice is in <https://style.tidyverse.org/files.html> and some package-specific advice is in <https://style.tidyverse.org/package-files.html>.

The file name should be meaningful and convey which functions are defined within.
While you're free to arrange functions into files as you wish, the two extremes are bad: don't put all functions into one file and don't put each function into its own separate file.
This advice should inform your general policy, but there are exceptions to every rule.
If a specific function is very large or has lots of documentation, it can make sense to give it its own file, named after the function.
More often, a single `.R` file will contain multiple function definitions: such as a main function and its supporting helpers, a family of related functions, or some combination of the two.

Here are some examples from the actual source of the [tidyr package](http://tidyr.tidyverse.org/):

```{r include = FALSE}
library(tidyverse)

# TODO: should these links be SHA'd to guard against change?

tidyr_separate <- tibble(
  `Organising principle` = "Main function plus helpers",
  `Source file` = "[tidyr/R/separate.R](https://github.com/tidyverse/tidyr/blob/master/R/separate.R)",
  Comments = "Defines the user-facing `separate()` (an S3 generic), a `data.frame` method, and private helpers"
)

tidyr_rectangle <- tibble(
  `Organising principle` = "Family of functions",
  `Source file` = "[tidyr/R/rectangle.R](https://github.com/tidyverse/tidyr/blob/master/R/rectangle.R)",
  Comments = "Defines a family of functions for \"rectangling\" nested lists (`hoist()` and the `unnest()` functions), all documented together in a big help topic, plus private helpers"
)

tidyr_uncount <- tibble(
  `Organising principle` = "One function",
  `Source file` = "[tidyr/R/uncount.R](https://github.com/tidyverse/tidyr/blob/master/R/uncount.R)",
  Comments = "Defines exactly one function, `uncount()`, that's not particulary large, but doesn't fit naturally into any other `.R` file"
)

dat <- bind_rows(tidyr_uncount, tidyr_separate, tidyr_rectangle)
```

```{r echo = FALSE}
knitr::kable(dat)
```

:::tip
Another file you often see in the wild is `R/utils.R`.
This is a common place to define small utilities that are used inside multiple package functions.
Since they serve as helpers to multiple functions, placing them in `R/utils.R` makes them easier to re-discover when you return to your package after a long break.

*TODO: link to Bob Rudis's blog post? <https://rud.is/b/2018/04/08/dissecting-r-package-utility-belts/>*
:::

If it's very hard to predict which file a function lives in, that suggests its time to separate your functions into more files or reconsider how you are naming your functions and/or files.

:::rstudio-tip
The arrangement of functions within files is less important in RStudio, which offers two ways to jump to the definition of a function:

* Press Ctrl + . (the period) then start typing the name. Keep typing to narrow
  the list and eventually pick a function (or file) to visit. This works for both
  functions and files in your project.
* With your cursor in a function name or with a function name selected, press
  F2. This works for functions defined in your package or in another package.
  
After navigating to a function with one of these methods, return to where you started by clicking the back arrow at the top-left of the editor or by pressing Ctrl + F9 (Windows & Linux) or Cmd + F9 (macOS).
:::

*TODO: I've let two images go here because unclear how that would/should work inside an RStudio tip. Are we OK with this? See them in the 1st ed at the end of this section: <http://r-pkgs.had.co.nz/r.html#r-organising>*

## Code style

We recommend following the tidyverse style guide (<https://style.tidyverse.org>), which goes into much more detail than we can here.
Its format also allows it to be a more dynamic document than this book.

Although the style guide explains the "what" and the "why", another important decision is *how* to enforce a specific code style.
For this we recommend the styler package (<https://styler.r-lib.org>); its default behaviour enforces the tidyverse style guide.
There are many ways to apply styler to your code, depending on the context:

* `styler::style_pkg()` restyles an entire R package.
* `styler::style_dir()` restyles all files in a directory.
* `usethis::use_tidy_style()` is wrapper that applies one of the above functions
  depending on whether the current project is an R package or not.
* `styler::style_file()` restyles a single file.
* `styler::style_text()` restyles a character vector.

:::rstudio-tip
When styler is installed, the RStudio Addins menu will offer several additional ways to style code:

* the active selection
* the active file
* the active package
:::

:::tip
The use of Git or another version control system is optional, but a recommended practice in the long-term.
We explain its importance in \@ref(git).
For example, it's nerve-wracking and somewhat dangerous to apply a function like `styler::style_pkg()` without some way to see exactly what changed and to accept/reject such changes in a granular way.
:::

The styler package can also be integrated with various platforms for hosting source code and doing continuous integration.
For example, the tidyverse packages use a GitHub Action that restyles a package when triggered by a special comment (`/style`) on a pull request.
This allows maintainers to focus on reviewing the substance of the pull request, without having to nitpick small issues of whitespace or indentation[^gha-style][^robot-pedantry].

[^gha-style]: See the [Commands workflow](https://github.com/r-lib/actions/tree/master/examples#commands-workflow) in the [GitHub Actions for the R language](https://github.com/r-lib/actions) repository.

[^robot-pedantry]: The [Robot Pedantry, Human Empathy](https://mikemcquaid.com/2018/06/05/robot-pedantry-human-empathy/) blog post by Mike McQuaid does an excellent job summarizing the benefit of automating tasks like code re-styling.

## Top-level code {#r-differences}

Up until now, you've probably been writing R code that's meant to be run as a __script__. This R code is saved in a file that you walk through interactively or execute via `source()` (from R) or via `Rscript` (in a shell).
There are two main differences between code in scripts and packages:

* In a script, code is run when it is loaded. In a package, code is run when the
  package is built. This means your package code should only create objects, the
  vast majority of which will be functions.
  
* Functions in your package will be used in situations that you didn't imagine.
  This means your functions need to be thoughtful in the way that they 
  interact with the outside world.

The next two sections expand on these important differences.

### Loading code

*TODO: I'd like to rework this section with a concrete example:*

1. Script-y code that defines 1-2 functions then uses them. Take care to use at
   least 1 other package in these functions and attach it via `library()` in
   the main script.
1. Move the function definitions and the `library()` call to a separate file,
   `source()` that from the script, use the functions.
1. Move the function into a little package. Import the dependency and namespace
   the calls. Show how the script looks now.
   
*TODO cont'd: I could maybe weave the `Sys.time()` example in.*

When you load a script with `source()`, every line of code is executed and the results are immediately made available.
Things are different in a package, because it is loaded in two steps.
When the package is built (e.g. by CRAN), all the code in `R/` is executed and the results are saved.
When you load a package, with `library()` or `require()`, the cached results are made available to you.
If you loaded scripts in the same way as packages, your code would look like this:

```{r, eval = FALSE}
# Load a script into a new environment and save it
env <- new.env(parent = emptyenv())
source("my-script.R", local = env)
save(envir = env, "my-script.Rdata")

# Later, in another R session
load("my-script.Rdata")
```

For example, take `x <- Sys.time()`.
If you put this in a script, `x` would tell you when the script was `source()`d.
But if you put that same code in a package, `x` would tell you when the package was _built_. 

This means that you should never run code at the top-level of a package: package code should only create objects, mostly functions.
For example, imagine your foo package contains this code:

```{r, eval = FALSE}
library(ggplot2)

show_mtcars <- function() {
  qplot(mpg, wt, data = mtcars)
}
```

If someone tries to use it:

```{r, eval = FALSE}
library(foo)
show_mtcars()
```

The code won't work because ggplot2's `qplot()` function won't be available: `library(foo)` doesn't re-execute `library(ggplot2)`.
The top-level R code in a package is only executed when the package is built, not when it's loaded.

To get around this problem you might be tempted to do:

```{r, eval = FALSE}
show_mtcars <- function() {
  library(ggplot2)
  qplot(mpg, wt, data = mtcars)
}
```

That's also problematic, as you'll see below.
Instead, describe the packages your code needs in the `DESCRIPTION` file, as you'll learn in [package dependencies](#dependencies).

### The R landscape

Another big difference between a script and a package is that other people are going to use your package, and they're going to use it in situations that you never imagined.
This means you need to pay attention to the R landscape, which includes not just the available functions and objects, but all the global settings.
You have changed the R landscape if you've loaded a package with `library()`, or changed a global option with `options()`, or modified the working directory with `setwd()`.
If the behaviour of _other_ functions differs before and after running your function, you've modified the landscape.
Changing the landscape is bad because it makes code much harder to understand. 

There are some functions that modify global settings that you should never use in package development, because there are better alternatives:

* __Don't use `library()` or `require()`__. These modify the search path, 
  affecting what functions are available from the global environment. 
  It's better to use the `DESCRIPTION` to specify your package's requirements, 
  as described in the next chapter. This also makes sure those packages are 
  installed when your package is installed.
  
* __Never use `source()`__ to load code from a file. `source()` modifies the
  current environment, inserting the results of executing the code. Instead, rely 
  on `devtools::load_all()` which automatically sources all files in `R/`.
  If you're using `source()` to create a dataset, instead switch to `data/`
  as described in [datasets](#data).

#### Managing state

Sometimes you cannot avoid modifying the state of the world, in which case you just have to make sure that you put things back the way you found them.

The first function to know about is base R's [`on.exit()`](https://rdrr.io/r/base/on.exit.html).
Inside your function body, every time you do something that should be undone **on exit**, you immediately register the cleanup code with `on.exit(expr, add = TRUE)`[^on-exit-add].

[^on-exit-add]: It's too bad `add = TRUE` isn't the default, because you almost always want this. Without it, each call to `on.exit()` clobbers the effect of previous calls.

Here's a `sloppy()` function that prints a number with a specific number of significant digits, by adjusting a global R option.

```{r include = FALSE}
op <- options()

# 'digits' might actually be manipulated for the whole book in common.R
# this is a typical default that I want in force during this example
options(digits = 7)
```

```{r}
sloppy <- function(x, sig_digits) {
  options(digits = sig_digits)
  print(x)
}

pi

sloppy(pi, 2)

pi
```

```{r include = FALSE}
options(digits = 7)
```

Notice how `pi` prints differently before and after the call to `sloppy()`?
Calling `sloppy()` has a side effect: it changes the `digits` option globally, not just within its own scope of operations.
This is what we want to avoid, *especially* in package functions.

*Don't worry, we're restoring global state (specifically, the `digits` option) behind the scenes here.*

Here's how to do better with `on.exit()`.

```{r}
neat <- function(x, sig_digits) {
  op <- options(digits = sig_digits)
  on.exit(options(op), add = TRUE)
  print(x)
}

pi

neat(pi, 2)

pi
```

The use of `on.exit()` ensures that `neat()` leaves `digits` the way that it found it.
`on.exit()` also works when you exit the function abnormally, i.e. due to error.
This is why it's a better choice than any do-it-yourself solution.

`on.exit()` is a very useful function and provides enough inspiration for an entire package: withr (<https://withr.r-lib.org>), which is a Swiss army knife for managing state in very flexible ways.
It's a very lean package that is designed for use in other packages and it's what we tend to use in new code, in package functions and tests, for situations like that above.

`withr::defer()` is very much like `on.exit()`, i.e. it schedules the execution of arbitrary code when the current function exits:

```{r}
neater <- function(x, sig_digits) {
  op <- options(digits = sig_digits)
  defer(options(op))
  print(x)
}

pi

neat(pi, 2)

pi
```

```{r include = FALSE}
# reset to the original value found at start of this example
options(op)
```

The default behaviour of `withr::defer()` tends to match our requirements better than `on.exit()`: `defer()` *adds* expressions to the *top* of the stack of deferred actions. (This can be achieved with `on.exit(add = TRUE, after = FALSE)`.)

The last killer feature `withr::defer()` is that its explicit `envir` argument makes it possible to write your own `on.exit()`-like helpers.
We don't demonstrate that here[^self-cleaning-test-fixtures].

[^self-cleaning-test-fixtures]: This idea is explored thoroughly, in the context of testing, in the blog post [Self-cleaning test fixtures](https://www.tidyverse.org/blog/2020/04/self-cleaning-test-fixtures/).

Certain state changes, such as modifying session options, come up so often that withr offers pre-made helpers.
These helpers come in two forms that are useful in different situations:

* `with_*()` functions are best for executing small snippets of code with a
  modified state
    ```{r eval = FALSE}
    neatest_with <- function(x, sig_digits) {
      # imagine lots of code here
      withr::with_options(
        list(digits = sig_digits),
        print(x)
      )
      # ... and a lot more code here
    }
    ```
* `local_*()` functions are best for modifying state "from now until the
  function exits"
    ```{r eval = FALSE}
    neatest_local <- function(x, sig_digits) {
      withr::local_options(list(digits = sig_digits))
      print(x)
      # imagine lots of code here
    }
    ```

Here are the state change helpers in withr that you are most likely to find useful:

| Do / undo this              | withr functions                     |
|-----------------------------|-------------------------------------|
| Set an R option             | `with_options()`, `local_options()` |
| Set an environment variable | `with_envvar()`, `local_envvar()`   |
| Change working directory    | `with_dir()`, `local_dir()`         |
| Set a graphics parameter    | `with_par()`, `local_par()`         |

#### Isolate functions with side effects

Creating plots and printing output to the console are two other ways of affecting the global R environment.
Often you can't avoid these (because they're important!), but it's good practice to isolate them in functions that __only__ produce output.
This also makes it easier for other people to repurpose your work for new uses.
For example, if you separate data preparation and plotting into two functions,
others can use your data prep work (which is often the hardest part!) to create new visualisations.

*TODO: is this a good place to talk about `format()` vs. `print()`? And the evils of doing cool calculations only in, e.g., a `summary()` method?*

#### Protect yourself from the environment

The flip side of the coin is that you should avoid relying on the user's landscape, which might be different to yours.
For example, functions like `read.csv()` are dangerous because the value of `stringsAsFactors` argument comes from the global option `stringsAsFactors`.
If you expect it to be `TRUE` (the default), and the user has set it to be `FALSE`, your code might fail. 

*TODO: we need to revisit this example in light of `stringsAsFactors` changes in R 4.0.*

### When you __do__ need side-effects

Occasionally, packages do need side-effects.
This is most common if your package talks to an external system --- you might need to do some initial setup when the package loads.
To do that, you can use two special functions: `.onLoad()` and `.onAttach()`.
These are called when the package is loaded and attached.
You'll learn about the distinction between the two in [Namespaces](#namespace).
For now, you should always use `.onLoad()` unless explicitly directed otherwise.

Some common uses of `.onLoad()` and `.onAttach()` are:

* To display an informative message when the package loads. This might make 
  usage conditions clear, or display useful tips. A startup messages is one 
  place where you should use `.onAttach()` instead of `.onLoad()`. To display 
  a startup message, always use `packageStartupMessage()`, and not `message()`. 
  This allows `suppressPackageStartupMessages()` to selectively suppress 
  package startup messages.

    ```{r, eval = FALSE}
    .onAttach <- function(libname, pkgname) {
      packageStartupMessage("Welcome to my package")
    }
    ```
    
* To set custom options for your package with `options()`. To avoid conflicts
  with other packages, ensure that you prefix option names with the name of your
  package. Also be careful not to override options that the user has already
  set.
  
  *TODO: revise this for current usethis.*
    
  I use the following code in devtools to set up useful options:
    
    ```{r, eval = FALSE}
    .onLoad <- function(libname, pkgname) {
      op <- options()
      op.devtools <- list(
        devtools.path = "~/R-dev",
        devtools.install.args = "",
        devtools.name = "Your name goes here",
        devtools.desc.author = "First Last <first.last@example.com> [aut, cre]",
        devtools.desc.license = "What license is it under?",
        devtools.desc.suggests = NULL,
        devtools.desc = list()
      )
      toset <- !(names(op.devtools) %in% names(op))
      if(any(toset)) options(op.devtools[toset])
    
      invisible()
    }
    ```
    
  Then devtools functions can use e.g. `getOption("devtools.name")` to get the
  name of the package author, and know that a sensible default value has already
  been set.
    
* To connect R to another programming language. For example, if you use rJava to
  talk to a `.jar` file, you need to call `rJava::.jpackage()`. To make C++
  classes available as reference classes in R with Rcpp modules, you call
  `Rcpp::loadRcppModules()`. 

* To register vignette engines with `tools::vignetteEngine()`.

As you can see in the examples, `.onLoad()` and `.onAttach()` are called with two arguments: `libname` and `pkgname`.
They're rarely used (they're a holdover from the days when you needed to use `library.dynam()` to load compiled code).
They give the path where the package is installed (the "library"), and the name of the package.

If you use `.onLoad()`, consider using `.onUnload()` to clean up any side effects.
By convention, `.onLoad()` and friends are usually saved in a file called `zzz.R`.
(Note that `.First.lib()` and `.Last.lib()` are old versions of `.onLoad()` and `.onUnload()` and should no longer be used.)
    
### S4 classes, generics and methods

Another type of side-effect is defining S4 classes, methods and generics.
R packages capture these side-effects so they can be replayed when the package is loaded, but they need to be called in the right order.
For example, before you can define a method, you must have defined both the generic and the class.
This requires that the R files be sourced in a specific order.
This order is controlled by the `Collate` field in the `DESCRIPTION`.
This is described in more detail in [documenting S4](#man-s4).

## CRAN notes {#r-cran}

(Each chapter will finish with some hints for submitting your package to CRAN.
If you don't plan on submitting your package to CRAN, feel free to ignore them!)

If you're planning on submitting your package to CRAN, you must use only ASCII characters in your `.R` files.
In practice, this means you are limited to the digits 0 to 9, lowercase letters 'a' to 'z', uppercase letters 'A' to 'Z', and common punctuation.

But sometimes you need to inline a small bit of character data that includes, e.g., a Greek letter (µ), an accented character (ü), or a symbol (30°).
You can use any Unicode character as long as you specify it in the special Unicode escape `"\u1234"` format.
The easiest way to find the correct code point is to use `stringi::stri_escape_unicode()`:

```{r}
x <- "This is a bullet •"
y <- "This is a bullet \u2022"
identical(x, y)

cat(stringi::stri_escape_unicode(x))
```

Sometimes you have the opposite problem.
You don't *intentionally* have any non-ASCII characters in your R code, but automated checks reveal that you do.

```
W  checking R files for non-ASCII characters ...
   Found the following file with non-ASCII characters:
     foo.R
   Portable packages must use only ASCII characters in their R code,
   except perhaps in comments.
   Use \uxxxx escapes for other characters.
```

The most common offenders are "curly" or "smart" single and double quotes that sneak in through copy/paste.
The functions `tools::showNonASCII()` and `tools::showNonASCIIfile(file)` help you find the offending file(s) and line(s).

```{r eval = FALSE}
tools::showNonASCIIfile("R/foo.R")
#> 666: #' If you<e2><80><99>ve copy/pasted quotes, watch out!
```
